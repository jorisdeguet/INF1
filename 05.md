# définition de fonction, utilisation de fonctions et librairie standard

Quand on approche un problème, on peut le découper en sous-problèmes.

Pour cela on peut trouver une solution au sous problème etc.

DEMO SUR LA SEQUENCE DE 1 11 21 etc

## Définition d'une fonction simple

```python
def double(x):
  return x*x
```

```python
def double(x):
  print x*x
```

Définir une fonction ne fait rien, on se donne juste un outil qu'on
pourra utiliser plus tard. Un peu comme quand on écrit une recette, on a 
rien à manger mais on pourra suivre la recette plus tard.

## Appel d'une fonction

On va regarder ce qui se passe sur un exemple simple
```python
def double(x):
  return x*x
a = double(4)
print(a)
```
1. quand on définit la fonction, il ne se passe rien, les 2 premières lignes ne font rien
2. **double(4)** appelle la fonction double
 - le paramètre est évalué, ça donne 4
 - 4 remplace *x* comme valeur du paramètre
 - la fonction calcule *x * x* soit *4 * 4* soit 16
 - *return* renvoie la valeur 16
 - alors *double(4)* vaut 16
3. on affiche la valeur avec un print

## Paramètre à la définition et à l'appel

Lors d'un appel d'une fonction, on évalue le paramètre fourni avant de le
passer à la fonction. Sur un exemple un peu plus complexe:
```python
def double(x):
  return x*x
a = 25
print( double( double(4) + double( 5 + double(a) ) ) )
```
Encore une fois, quand ça se complique le mode débogage devient notre 
meilleur ami pour ne pas abandonner.

## Typage (optionnel mais bien utile) d'une fonction

## Paramètre nommé

```python
def double(*x, ):
  return x*x
a = 25
print( double( double(4) + double( 5 + double(a) ) ) )
```

## Paramètre avec valeur par défaut


```python
def racine(nombre, base=2):
  # ton code ici
  return 1
```
